// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'rule_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$RuleEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(AutomatoSignal? signal) signalSelected,
    required TResult Function(AutomatoOutput? output) outputSelected,
    required TResult Function(AutomatoState? state) stateSelected,
    required TResult Function(AutomatoState? state) transitionSelected,
    required TResult Function() memorize,
    required TResult Function(AutomatoSignal signal, AutomatoRule rule) remove,
    required TResult Function(AutomatoRule rule) addRule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Reset value) reset,
    required TResult Function(_SignalSelected value) signalSelected,
    required TResult Function(_OutputSelected value) outputSelected,
    required TResult Function(_StateSelected value) stateSelected,
    required TResult Function(_TransitionSelected value) transitionSelected,
    required TResult Function(_Memorize value) memorize,
    required TResult Function(_Remove value) remove,
    required TResult Function(_AddRule value) addRule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RuleEventCopyWith<$Res> {
  factory $RuleEventCopyWith(RuleEvent value, $Res Function(RuleEvent) then) =
      _$RuleEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$RuleEventCopyWithImpl<$Res> implements $RuleEventCopyWith<$Res> {
  _$RuleEventCopyWithImpl(this._value, this._then);

  final RuleEvent _value;
  // ignore: unused_field
  final $Res Function(RuleEvent) _then;
}

/// @nodoc
abstract class _$ResetCopyWith<$Res> {
  factory _$ResetCopyWith(_Reset value, $Res Function(_Reset) then) =
      __$ResetCopyWithImpl<$Res>;
}

/// @nodoc
class __$ResetCopyWithImpl<$Res> extends _$RuleEventCopyWithImpl<$Res>
    implements _$ResetCopyWith<$Res> {
  __$ResetCopyWithImpl(_Reset _value, $Res Function(_Reset) _then)
      : super(_value, (v) => _then(v as _Reset));

  @override
  _Reset get _value => super._value as _Reset;
}

/// @nodoc

class _$_Reset with DiagnosticableTreeMixin implements _Reset {
  const _$_Reset();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RuleEvent.reset()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'RuleEvent.reset'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Reset);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(AutomatoSignal? signal) signalSelected,
    required TResult Function(AutomatoOutput? output) outputSelected,
    required TResult Function(AutomatoState? state) stateSelected,
    required TResult Function(AutomatoState? state) transitionSelected,
    required TResult Function() memorize,
    required TResult Function(AutomatoSignal signal, AutomatoRule rule) remove,
    required TResult Function(AutomatoRule rule) addRule,
  }) {
    return reset();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
  }) {
    return reset?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Reset value) reset,
    required TResult Function(_SignalSelected value) signalSelected,
    required TResult Function(_OutputSelected value) outputSelected,
    required TResult Function(_StateSelected value) stateSelected,
    required TResult Function(_TransitionSelected value) transitionSelected,
    required TResult Function(_Memorize value) memorize,
    required TResult Function(_Remove value) remove,
    required TResult Function(_AddRule value) addRule,
  }) {
    return reset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
  }) {
    return reset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(this);
    }
    return orElse();
  }
}

abstract class _Reset implements RuleEvent {
  const factory _Reset() = _$_Reset;
}

/// @nodoc
abstract class _$SignalSelectedCopyWith<$Res> {
  factory _$SignalSelectedCopyWith(
          _SignalSelected value, $Res Function(_SignalSelected) then) =
      __$SignalSelectedCopyWithImpl<$Res>;
  $Res call({AutomatoSignal? signal});
}

/// @nodoc
class __$SignalSelectedCopyWithImpl<$Res> extends _$RuleEventCopyWithImpl<$Res>
    implements _$SignalSelectedCopyWith<$Res> {
  __$SignalSelectedCopyWithImpl(
      _SignalSelected _value, $Res Function(_SignalSelected) _then)
      : super(_value, (v) => _then(v as _SignalSelected));

  @override
  _SignalSelected get _value => super._value as _SignalSelected;

  @override
  $Res call({
    Object? signal = freezed,
  }) {
    return _then(_SignalSelected(
      signal == freezed
          ? _value.signal
          : signal // ignore: cast_nullable_to_non_nullable
              as AutomatoSignal?,
    ));
  }
}

/// @nodoc

class _$_SignalSelected
    with DiagnosticableTreeMixin
    implements _SignalSelected {
  const _$_SignalSelected(this.signal);

  @override
  final AutomatoSignal? signal;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RuleEvent.signalSelected(signal: $signal)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RuleEvent.signalSelected'))
      ..add(DiagnosticsProperty('signal', signal));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SignalSelected &&
            const DeepCollectionEquality().equals(other.signal, signal));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(signal));

  @JsonKey(ignore: true)
  @override
  _$SignalSelectedCopyWith<_SignalSelected> get copyWith =>
      __$SignalSelectedCopyWithImpl<_SignalSelected>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(AutomatoSignal? signal) signalSelected,
    required TResult Function(AutomatoOutput? output) outputSelected,
    required TResult Function(AutomatoState? state) stateSelected,
    required TResult Function(AutomatoState? state) transitionSelected,
    required TResult Function() memorize,
    required TResult Function(AutomatoSignal signal, AutomatoRule rule) remove,
    required TResult Function(AutomatoRule rule) addRule,
  }) {
    return signalSelected(signal);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
  }) {
    return signalSelected?.call(signal);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
    required TResult orElse(),
  }) {
    if (signalSelected != null) {
      return signalSelected(signal);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Reset value) reset,
    required TResult Function(_SignalSelected value) signalSelected,
    required TResult Function(_OutputSelected value) outputSelected,
    required TResult Function(_StateSelected value) stateSelected,
    required TResult Function(_TransitionSelected value) transitionSelected,
    required TResult Function(_Memorize value) memorize,
    required TResult Function(_Remove value) remove,
    required TResult Function(_AddRule value) addRule,
  }) {
    return signalSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
  }) {
    return signalSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
    required TResult orElse(),
  }) {
    if (signalSelected != null) {
      return signalSelected(this);
    }
    return orElse();
  }
}

abstract class _SignalSelected implements RuleEvent {
  const factory _SignalSelected(final AutomatoSignal? signal) =
      _$_SignalSelected;

  AutomatoSignal? get signal => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$SignalSelectedCopyWith<_SignalSelected> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$OutputSelectedCopyWith<$Res> {
  factory _$OutputSelectedCopyWith(
          _OutputSelected value, $Res Function(_OutputSelected) then) =
      __$OutputSelectedCopyWithImpl<$Res>;
  $Res call({AutomatoOutput? output});
}

/// @nodoc
class __$OutputSelectedCopyWithImpl<$Res> extends _$RuleEventCopyWithImpl<$Res>
    implements _$OutputSelectedCopyWith<$Res> {
  __$OutputSelectedCopyWithImpl(
      _OutputSelected _value, $Res Function(_OutputSelected) _then)
      : super(_value, (v) => _then(v as _OutputSelected));

  @override
  _OutputSelected get _value => super._value as _OutputSelected;

  @override
  $Res call({
    Object? output = freezed,
  }) {
    return _then(_OutputSelected(
      output == freezed
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as AutomatoOutput?,
    ));
  }
}

/// @nodoc

class _$_OutputSelected
    with DiagnosticableTreeMixin
    implements _OutputSelected {
  const _$_OutputSelected(this.output);

  @override
  final AutomatoOutput? output;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RuleEvent.outputSelected(output: $output)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RuleEvent.outputSelected'))
      ..add(DiagnosticsProperty('output', output));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _OutputSelected &&
            const DeepCollectionEquality().equals(other.output, output));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(output));

  @JsonKey(ignore: true)
  @override
  _$OutputSelectedCopyWith<_OutputSelected> get copyWith =>
      __$OutputSelectedCopyWithImpl<_OutputSelected>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(AutomatoSignal? signal) signalSelected,
    required TResult Function(AutomatoOutput? output) outputSelected,
    required TResult Function(AutomatoState? state) stateSelected,
    required TResult Function(AutomatoState? state) transitionSelected,
    required TResult Function() memorize,
    required TResult Function(AutomatoSignal signal, AutomatoRule rule) remove,
    required TResult Function(AutomatoRule rule) addRule,
  }) {
    return outputSelected(output);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
  }) {
    return outputSelected?.call(output);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
    required TResult orElse(),
  }) {
    if (outputSelected != null) {
      return outputSelected(output);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Reset value) reset,
    required TResult Function(_SignalSelected value) signalSelected,
    required TResult Function(_OutputSelected value) outputSelected,
    required TResult Function(_StateSelected value) stateSelected,
    required TResult Function(_TransitionSelected value) transitionSelected,
    required TResult Function(_Memorize value) memorize,
    required TResult Function(_Remove value) remove,
    required TResult Function(_AddRule value) addRule,
  }) {
    return outputSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
  }) {
    return outputSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
    required TResult orElse(),
  }) {
    if (outputSelected != null) {
      return outputSelected(this);
    }
    return orElse();
  }
}

abstract class _OutputSelected implements RuleEvent {
  const factory _OutputSelected(final AutomatoOutput? output) =
      _$_OutputSelected;

  AutomatoOutput? get output => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$OutputSelectedCopyWith<_OutputSelected> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$StateSelectedCopyWith<$Res> {
  factory _$StateSelectedCopyWith(
          _StateSelected value, $Res Function(_StateSelected) then) =
      __$StateSelectedCopyWithImpl<$Res>;
  $Res call({AutomatoState? state});
}

/// @nodoc
class __$StateSelectedCopyWithImpl<$Res> extends _$RuleEventCopyWithImpl<$Res>
    implements _$StateSelectedCopyWith<$Res> {
  __$StateSelectedCopyWithImpl(
      _StateSelected _value, $Res Function(_StateSelected) _then)
      : super(_value, (v) => _then(v as _StateSelected));

  @override
  _StateSelected get _value => super._value as _StateSelected;

  @override
  $Res call({
    Object? state = freezed,
  }) {
    return _then(_StateSelected(
      state == freezed
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as AutomatoState?,
    ));
  }
}

/// @nodoc

class _$_StateSelected with DiagnosticableTreeMixin implements _StateSelected {
  const _$_StateSelected(this.state);

  @override
  final AutomatoState? state;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RuleEvent.stateSelected(state: $state)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RuleEvent.stateSelected'))
      ..add(DiagnosticsProperty('state', state));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _StateSelected &&
            const DeepCollectionEquality().equals(other.state, state));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(state));

  @JsonKey(ignore: true)
  @override
  _$StateSelectedCopyWith<_StateSelected> get copyWith =>
      __$StateSelectedCopyWithImpl<_StateSelected>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(AutomatoSignal? signal) signalSelected,
    required TResult Function(AutomatoOutput? output) outputSelected,
    required TResult Function(AutomatoState? state) stateSelected,
    required TResult Function(AutomatoState? state) transitionSelected,
    required TResult Function() memorize,
    required TResult Function(AutomatoSignal signal, AutomatoRule rule) remove,
    required TResult Function(AutomatoRule rule) addRule,
  }) {
    return stateSelected(state);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
  }) {
    return stateSelected?.call(state);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
    required TResult orElse(),
  }) {
    if (stateSelected != null) {
      return stateSelected(state);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Reset value) reset,
    required TResult Function(_SignalSelected value) signalSelected,
    required TResult Function(_OutputSelected value) outputSelected,
    required TResult Function(_StateSelected value) stateSelected,
    required TResult Function(_TransitionSelected value) transitionSelected,
    required TResult Function(_Memorize value) memorize,
    required TResult Function(_Remove value) remove,
    required TResult Function(_AddRule value) addRule,
  }) {
    return stateSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
  }) {
    return stateSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
    required TResult orElse(),
  }) {
    if (stateSelected != null) {
      return stateSelected(this);
    }
    return orElse();
  }
}

abstract class _StateSelected implements RuleEvent {
  const factory _StateSelected(final AutomatoState? state) = _$_StateSelected;

  AutomatoState? get state => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$StateSelectedCopyWith<_StateSelected> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$TransitionSelectedCopyWith<$Res> {
  factory _$TransitionSelectedCopyWith(
          _TransitionSelected value, $Res Function(_TransitionSelected) then) =
      __$TransitionSelectedCopyWithImpl<$Res>;
  $Res call({AutomatoState? state});
}

/// @nodoc
class __$TransitionSelectedCopyWithImpl<$Res>
    extends _$RuleEventCopyWithImpl<$Res>
    implements _$TransitionSelectedCopyWith<$Res> {
  __$TransitionSelectedCopyWithImpl(
      _TransitionSelected _value, $Res Function(_TransitionSelected) _then)
      : super(_value, (v) => _then(v as _TransitionSelected));

  @override
  _TransitionSelected get _value => super._value as _TransitionSelected;

  @override
  $Res call({
    Object? state = freezed,
  }) {
    return _then(_TransitionSelected(
      state == freezed
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as AutomatoState?,
    ));
  }
}

/// @nodoc

class _$_TransitionSelected
    with DiagnosticableTreeMixin
    implements _TransitionSelected {
  const _$_TransitionSelected(this.state);

  @override
  final AutomatoState? state;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RuleEvent.transitionSelected(state: $state)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RuleEvent.transitionSelected'))
      ..add(DiagnosticsProperty('state', state));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TransitionSelected &&
            const DeepCollectionEquality().equals(other.state, state));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(state));

  @JsonKey(ignore: true)
  @override
  _$TransitionSelectedCopyWith<_TransitionSelected> get copyWith =>
      __$TransitionSelectedCopyWithImpl<_TransitionSelected>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(AutomatoSignal? signal) signalSelected,
    required TResult Function(AutomatoOutput? output) outputSelected,
    required TResult Function(AutomatoState? state) stateSelected,
    required TResult Function(AutomatoState? state) transitionSelected,
    required TResult Function() memorize,
    required TResult Function(AutomatoSignal signal, AutomatoRule rule) remove,
    required TResult Function(AutomatoRule rule) addRule,
  }) {
    return transitionSelected(state);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
  }) {
    return transitionSelected?.call(state);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
    required TResult orElse(),
  }) {
    if (transitionSelected != null) {
      return transitionSelected(state);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Reset value) reset,
    required TResult Function(_SignalSelected value) signalSelected,
    required TResult Function(_OutputSelected value) outputSelected,
    required TResult Function(_StateSelected value) stateSelected,
    required TResult Function(_TransitionSelected value) transitionSelected,
    required TResult Function(_Memorize value) memorize,
    required TResult Function(_Remove value) remove,
    required TResult Function(_AddRule value) addRule,
  }) {
    return transitionSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
  }) {
    return transitionSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
    required TResult orElse(),
  }) {
    if (transitionSelected != null) {
      return transitionSelected(this);
    }
    return orElse();
  }
}

abstract class _TransitionSelected implements RuleEvent {
  const factory _TransitionSelected(final AutomatoState? state) =
      _$_TransitionSelected;

  AutomatoState? get state => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$TransitionSelectedCopyWith<_TransitionSelected> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$MemorizeCopyWith<$Res> {
  factory _$MemorizeCopyWith(_Memorize value, $Res Function(_Memorize) then) =
      __$MemorizeCopyWithImpl<$Res>;
}

/// @nodoc
class __$MemorizeCopyWithImpl<$Res> extends _$RuleEventCopyWithImpl<$Res>
    implements _$MemorizeCopyWith<$Res> {
  __$MemorizeCopyWithImpl(_Memorize _value, $Res Function(_Memorize) _then)
      : super(_value, (v) => _then(v as _Memorize));

  @override
  _Memorize get _value => super._value as _Memorize;
}

/// @nodoc

class _$_Memorize with DiagnosticableTreeMixin implements _Memorize {
  const _$_Memorize();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RuleEvent.memorize()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'RuleEvent.memorize'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Memorize);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(AutomatoSignal? signal) signalSelected,
    required TResult Function(AutomatoOutput? output) outputSelected,
    required TResult Function(AutomatoState? state) stateSelected,
    required TResult Function(AutomatoState? state) transitionSelected,
    required TResult Function() memorize,
    required TResult Function(AutomatoSignal signal, AutomatoRule rule) remove,
    required TResult Function(AutomatoRule rule) addRule,
  }) {
    return memorize();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
  }) {
    return memorize?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
    required TResult orElse(),
  }) {
    if (memorize != null) {
      return memorize();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Reset value) reset,
    required TResult Function(_SignalSelected value) signalSelected,
    required TResult Function(_OutputSelected value) outputSelected,
    required TResult Function(_StateSelected value) stateSelected,
    required TResult Function(_TransitionSelected value) transitionSelected,
    required TResult Function(_Memorize value) memorize,
    required TResult Function(_Remove value) remove,
    required TResult Function(_AddRule value) addRule,
  }) {
    return memorize(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
  }) {
    return memorize?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
    required TResult orElse(),
  }) {
    if (memorize != null) {
      return memorize(this);
    }
    return orElse();
  }
}

abstract class _Memorize implements RuleEvent {
  const factory _Memorize() = _$_Memorize;
}

/// @nodoc
abstract class _$RemoveCopyWith<$Res> {
  factory _$RemoveCopyWith(_Remove value, $Res Function(_Remove) then) =
      __$RemoveCopyWithImpl<$Res>;
  $Res call({AutomatoSignal signal, AutomatoRule rule});
}

/// @nodoc
class __$RemoveCopyWithImpl<$Res> extends _$RuleEventCopyWithImpl<$Res>
    implements _$RemoveCopyWith<$Res> {
  __$RemoveCopyWithImpl(_Remove _value, $Res Function(_Remove) _then)
      : super(_value, (v) => _then(v as _Remove));

  @override
  _Remove get _value => super._value as _Remove;

  @override
  $Res call({
    Object? signal = freezed,
    Object? rule = freezed,
  }) {
    return _then(_Remove(
      signal == freezed
          ? _value.signal
          : signal // ignore: cast_nullable_to_non_nullable
              as AutomatoSignal,
      rule == freezed
          ? _value.rule
          : rule // ignore: cast_nullable_to_non_nullable
              as AutomatoRule,
    ));
  }
}

/// @nodoc

class _$_Remove with DiagnosticableTreeMixin implements _Remove {
  const _$_Remove(this.signal, this.rule);

  @override
  final AutomatoSignal signal;
  @override
  final AutomatoRule rule;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RuleEvent.remove(signal: $signal, rule: $rule)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RuleEvent.remove'))
      ..add(DiagnosticsProperty('signal', signal))
      ..add(DiagnosticsProperty('rule', rule));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Remove &&
            const DeepCollectionEquality().equals(other.signal, signal) &&
            const DeepCollectionEquality().equals(other.rule, rule));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(signal),
      const DeepCollectionEquality().hash(rule));

  @JsonKey(ignore: true)
  @override
  _$RemoveCopyWith<_Remove> get copyWith =>
      __$RemoveCopyWithImpl<_Remove>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(AutomatoSignal? signal) signalSelected,
    required TResult Function(AutomatoOutput? output) outputSelected,
    required TResult Function(AutomatoState? state) stateSelected,
    required TResult Function(AutomatoState? state) transitionSelected,
    required TResult Function() memorize,
    required TResult Function(AutomatoSignal signal, AutomatoRule rule) remove,
    required TResult Function(AutomatoRule rule) addRule,
  }) {
    return remove(signal, rule);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
  }) {
    return remove?.call(signal, rule);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
    required TResult orElse(),
  }) {
    if (remove != null) {
      return remove(signal, rule);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Reset value) reset,
    required TResult Function(_SignalSelected value) signalSelected,
    required TResult Function(_OutputSelected value) outputSelected,
    required TResult Function(_StateSelected value) stateSelected,
    required TResult Function(_TransitionSelected value) transitionSelected,
    required TResult Function(_Memorize value) memorize,
    required TResult Function(_Remove value) remove,
    required TResult Function(_AddRule value) addRule,
  }) {
    return remove(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
  }) {
    return remove?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
    required TResult orElse(),
  }) {
    if (remove != null) {
      return remove(this);
    }
    return orElse();
  }
}

abstract class _Remove implements RuleEvent {
  const factory _Remove(final AutomatoSignal signal, final AutomatoRule rule) =
      _$_Remove;

  AutomatoSignal get signal => throw _privateConstructorUsedError;
  AutomatoRule get rule => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$RemoveCopyWith<_Remove> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$AddRuleCopyWith<$Res> {
  factory _$AddRuleCopyWith(_AddRule value, $Res Function(_AddRule) then) =
      __$AddRuleCopyWithImpl<$Res>;
  $Res call({AutomatoRule rule});
}

/// @nodoc
class __$AddRuleCopyWithImpl<$Res> extends _$RuleEventCopyWithImpl<$Res>
    implements _$AddRuleCopyWith<$Res> {
  __$AddRuleCopyWithImpl(_AddRule _value, $Res Function(_AddRule) _then)
      : super(_value, (v) => _then(v as _AddRule));

  @override
  _AddRule get _value => super._value as _AddRule;

  @override
  $Res call({
    Object? rule = freezed,
  }) {
    return _then(_AddRule(
      rule == freezed
          ? _value.rule
          : rule // ignore: cast_nullable_to_non_nullable
              as AutomatoRule,
    ));
  }
}

/// @nodoc

class _$_AddRule with DiagnosticableTreeMixin implements _AddRule {
  const _$_AddRule(this.rule);

  @override
  final AutomatoRule rule;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RuleEvent.addRule(rule: $rule)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RuleEvent.addRule'))
      ..add(DiagnosticsProperty('rule', rule));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AddRule &&
            const DeepCollectionEquality().equals(other.rule, rule));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(rule));

  @JsonKey(ignore: true)
  @override
  _$AddRuleCopyWith<_AddRule> get copyWith =>
      __$AddRuleCopyWithImpl<_AddRule>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() reset,
    required TResult Function(AutomatoSignal? signal) signalSelected,
    required TResult Function(AutomatoOutput? output) outputSelected,
    required TResult Function(AutomatoState? state) stateSelected,
    required TResult Function(AutomatoState? state) transitionSelected,
    required TResult Function() memorize,
    required TResult Function(AutomatoSignal signal, AutomatoRule rule) remove,
    required TResult Function(AutomatoRule rule) addRule,
  }) {
    return addRule(rule);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
  }) {
    return addRule?.call(rule);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? reset,
    TResult Function(AutomatoSignal? signal)? signalSelected,
    TResult Function(AutomatoOutput? output)? outputSelected,
    TResult Function(AutomatoState? state)? stateSelected,
    TResult Function(AutomatoState? state)? transitionSelected,
    TResult Function()? memorize,
    TResult Function(AutomatoSignal signal, AutomatoRule rule)? remove,
    TResult Function(AutomatoRule rule)? addRule,
    required TResult orElse(),
  }) {
    if (addRule != null) {
      return addRule(rule);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Reset value) reset,
    required TResult Function(_SignalSelected value) signalSelected,
    required TResult Function(_OutputSelected value) outputSelected,
    required TResult Function(_StateSelected value) stateSelected,
    required TResult Function(_TransitionSelected value) transitionSelected,
    required TResult Function(_Memorize value) memorize,
    required TResult Function(_Remove value) remove,
    required TResult Function(_AddRule value) addRule,
  }) {
    return addRule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
  }) {
    return addRule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Reset value)? reset,
    TResult Function(_SignalSelected value)? signalSelected,
    TResult Function(_OutputSelected value)? outputSelected,
    TResult Function(_StateSelected value)? stateSelected,
    TResult Function(_TransitionSelected value)? transitionSelected,
    TResult Function(_Memorize value)? memorize,
    TResult Function(_Remove value)? remove,
    TResult Function(_AddRule value)? addRule,
    required TResult orElse(),
  }) {
    if (addRule != null) {
      return addRule(this);
    }
    return orElse();
  }
}

abstract class _AddRule implements RuleEvent {
  const factory _AddRule(final AutomatoRule rule) = _$_AddRule;

  AutomatoRule get rule => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$AddRuleCopyWith<_AddRule> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RuleState {
  Map<AutomatoSignal, List<AutomatoRule>> get memorized =>
      throw _privateConstructorUsedError;
  AutomatoSignal? get signal => throw _privateConstructorUsedError;
  AutomatoOutput? get output => throw _privateConstructorUsedError;
  AutomatoState? get current => throw _privateConstructorUsedError;
  AutomatoState? get transition => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)
        editing,
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)
        success,
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)
        error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        editing,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        success,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)?
        error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        editing,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        success,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)?
        error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Editing value) editing,
    required TResult Function(_Success value) success,
    required TResult Function(_Error value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Editing value)? editing,
    TResult Function(_Success value)? success,
    TResult Function(_Error value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Editing value)? editing,
    TResult Function(_Success value)? success,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RuleStateCopyWith<RuleState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RuleStateCopyWith<$Res> {
  factory $RuleStateCopyWith(RuleState value, $Res Function(RuleState) then) =
      _$RuleStateCopyWithImpl<$Res>;
  $Res call(
      {Map<AutomatoSignal, List<AutomatoRule>> memorized,
      AutomatoSignal? signal,
      AutomatoOutput? output,
      AutomatoState? current,
      AutomatoState? transition});
}

/// @nodoc
class _$RuleStateCopyWithImpl<$Res> implements $RuleStateCopyWith<$Res> {
  _$RuleStateCopyWithImpl(this._value, this._then);

  final RuleState _value;
  // ignore: unused_field
  final $Res Function(RuleState) _then;

  @override
  $Res call({
    Object? memorized = freezed,
    Object? signal = freezed,
    Object? output = freezed,
    Object? current = freezed,
    Object? transition = freezed,
  }) {
    return _then(_value.copyWith(
      memorized: memorized == freezed
          ? _value.memorized
          : memorized // ignore: cast_nullable_to_non_nullable
              as Map<AutomatoSignal, List<AutomatoRule>>,
      signal: signal == freezed
          ? _value.signal
          : signal // ignore: cast_nullable_to_non_nullable
              as AutomatoSignal?,
      output: output == freezed
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as AutomatoOutput?,
      current: current == freezed
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as AutomatoState?,
      transition: transition == freezed
          ? _value.transition
          : transition // ignore: cast_nullable_to_non_nullable
              as AutomatoState?,
    ));
  }
}

/// @nodoc
abstract class _$EditingCopyWith<$Res> implements $RuleStateCopyWith<$Res> {
  factory _$EditingCopyWith(_Editing value, $Res Function(_Editing) then) =
      __$EditingCopyWithImpl<$Res>;
  @override
  $Res call(
      {Map<AutomatoSignal, List<AutomatoRule>> memorized,
      AutomatoSignal? signal,
      AutomatoOutput? output,
      AutomatoState? current,
      AutomatoState? transition});
}

/// @nodoc
class __$EditingCopyWithImpl<$Res> extends _$RuleStateCopyWithImpl<$Res>
    implements _$EditingCopyWith<$Res> {
  __$EditingCopyWithImpl(_Editing _value, $Res Function(_Editing) _then)
      : super(_value, (v) => _then(v as _Editing));

  @override
  _Editing get _value => super._value as _Editing;

  @override
  $Res call({
    Object? memorized = freezed,
    Object? signal = freezed,
    Object? output = freezed,
    Object? current = freezed,
    Object? transition = freezed,
  }) {
    return _then(_Editing(
      memorized: memorized == freezed
          ? _value.memorized
          : memorized // ignore: cast_nullable_to_non_nullable
              as Map<AutomatoSignal, List<AutomatoRule>>,
      signal: signal == freezed
          ? _value.signal
          : signal // ignore: cast_nullable_to_non_nullable
              as AutomatoSignal?,
      output: output == freezed
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as AutomatoOutput?,
      current: current == freezed
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as AutomatoState?,
      transition: transition == freezed
          ? _value.transition
          : transition // ignore: cast_nullable_to_non_nullable
              as AutomatoState?,
    ));
  }
}

/// @nodoc

class _$_Editing extends _Editing with DiagnosticableTreeMixin {
  const _$_Editing(
      {required final Map<AutomatoSignal, List<AutomatoRule>> memorized,
      this.signal,
      this.output,
      this.current,
      this.transition})
      : _memorized = memorized,
        super._();

  final Map<AutomatoSignal, List<AutomatoRule>> _memorized;
  @override
  Map<AutomatoSignal, List<AutomatoRule>> get memorized {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_memorized);
  }

  @override
  final AutomatoSignal? signal;
  @override
  final AutomatoOutput? output;
  @override
  final AutomatoState? current;
  @override
  final AutomatoState? transition;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RuleState.editing(memorized: $memorized, signal: $signal, output: $output, current: $current, transition: $transition)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RuleState.editing'))
      ..add(DiagnosticsProperty('memorized', memorized))
      ..add(DiagnosticsProperty('signal', signal))
      ..add(DiagnosticsProperty('output', output))
      ..add(DiagnosticsProperty('current', current))
      ..add(DiagnosticsProperty('transition', transition));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Editing &&
            const DeepCollectionEquality().equals(other.memorized, memorized) &&
            const DeepCollectionEquality().equals(other.signal, signal) &&
            const DeepCollectionEquality().equals(other.output, output) &&
            const DeepCollectionEquality().equals(other.current, current) &&
            const DeepCollectionEquality()
                .equals(other.transition, transition));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(memorized),
      const DeepCollectionEquality().hash(signal),
      const DeepCollectionEquality().hash(output),
      const DeepCollectionEquality().hash(current),
      const DeepCollectionEquality().hash(transition));

  @JsonKey(ignore: true)
  @override
  _$EditingCopyWith<_Editing> get copyWith =>
      __$EditingCopyWithImpl<_Editing>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)
        editing,
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)
        success,
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)
        error,
  }) {
    return editing(memorized, signal, output, current, transition);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        editing,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        success,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)?
        error,
  }) {
    return editing?.call(memorized, signal, output, current, transition);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        editing,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        success,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)?
        error,
    required TResult orElse(),
  }) {
    if (editing != null) {
      return editing(memorized, signal, output, current, transition);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Editing value) editing,
    required TResult Function(_Success value) success,
    required TResult Function(_Error value) error,
  }) {
    return editing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Editing value)? editing,
    TResult Function(_Success value)? success,
    TResult Function(_Error value)? error,
  }) {
    return editing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Editing value)? editing,
    TResult Function(_Success value)? success,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (editing != null) {
      return editing(this);
    }
    return orElse();
  }
}

abstract class _Editing extends RuleState {
  const factory _Editing(
      {required final Map<AutomatoSignal, List<AutomatoRule>> memorized,
      final AutomatoSignal? signal,
      final AutomatoOutput? output,
      final AutomatoState? current,
      final AutomatoState? transition}) = _$_Editing;
  const _Editing._() : super._();

  @override
  Map<AutomatoSignal, List<AutomatoRule>> get memorized =>
      throw _privateConstructorUsedError;
  @override
  AutomatoSignal? get signal => throw _privateConstructorUsedError;
  @override
  AutomatoOutput? get output => throw _privateConstructorUsedError;
  @override
  AutomatoState? get current => throw _privateConstructorUsedError;
  @override
  AutomatoState? get transition => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EditingCopyWith<_Editing> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$SuccessCopyWith<$Res> implements $RuleStateCopyWith<$Res> {
  factory _$SuccessCopyWith(_Success value, $Res Function(_Success) then) =
      __$SuccessCopyWithImpl<$Res>;
  @override
  $Res call(
      {Map<AutomatoSignal, List<AutomatoRule>> memorized,
      AutomatoSignal? signal,
      AutomatoOutput? output,
      AutomatoState? current,
      AutomatoState? transition});
}

/// @nodoc
class __$SuccessCopyWithImpl<$Res> extends _$RuleStateCopyWithImpl<$Res>
    implements _$SuccessCopyWith<$Res> {
  __$SuccessCopyWithImpl(_Success _value, $Res Function(_Success) _then)
      : super(_value, (v) => _then(v as _Success));

  @override
  _Success get _value => super._value as _Success;

  @override
  $Res call({
    Object? memorized = freezed,
    Object? signal = freezed,
    Object? output = freezed,
    Object? current = freezed,
    Object? transition = freezed,
  }) {
    return _then(_Success(
      memorized: memorized == freezed
          ? _value.memorized
          : memorized // ignore: cast_nullable_to_non_nullable
              as Map<AutomatoSignal, List<AutomatoRule>>,
      signal: signal == freezed
          ? _value.signal
          : signal // ignore: cast_nullable_to_non_nullable
              as AutomatoSignal?,
      output: output == freezed
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as AutomatoOutput?,
      current: current == freezed
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as AutomatoState?,
      transition: transition == freezed
          ? _value.transition
          : transition // ignore: cast_nullable_to_non_nullable
              as AutomatoState?,
    ));
  }
}

/// @nodoc

class _$_Success extends _Success with DiagnosticableTreeMixin {
  const _$_Success(
      {required final Map<AutomatoSignal, List<AutomatoRule>> memorized,
      this.signal,
      this.output,
      this.current,
      this.transition})
      : _memorized = memorized,
        super._();

  final Map<AutomatoSignal, List<AutomatoRule>> _memorized;
  @override
  Map<AutomatoSignal, List<AutomatoRule>> get memorized {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_memorized);
  }

  @override
  final AutomatoSignal? signal;
  @override
  final AutomatoOutput? output;
  @override
  final AutomatoState? current;
  @override
  final AutomatoState? transition;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RuleState.success(memorized: $memorized, signal: $signal, output: $output, current: $current, transition: $transition)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RuleState.success'))
      ..add(DiagnosticsProperty('memorized', memorized))
      ..add(DiagnosticsProperty('signal', signal))
      ..add(DiagnosticsProperty('output', output))
      ..add(DiagnosticsProperty('current', current))
      ..add(DiagnosticsProperty('transition', transition));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Success &&
            const DeepCollectionEquality().equals(other.memorized, memorized) &&
            const DeepCollectionEquality().equals(other.signal, signal) &&
            const DeepCollectionEquality().equals(other.output, output) &&
            const DeepCollectionEquality().equals(other.current, current) &&
            const DeepCollectionEquality()
                .equals(other.transition, transition));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(memorized),
      const DeepCollectionEquality().hash(signal),
      const DeepCollectionEquality().hash(output),
      const DeepCollectionEquality().hash(current),
      const DeepCollectionEquality().hash(transition));

  @JsonKey(ignore: true)
  @override
  _$SuccessCopyWith<_Success> get copyWith =>
      __$SuccessCopyWithImpl<_Success>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)
        editing,
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)
        success,
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)
        error,
  }) {
    return success(memorized, signal, output, current, transition);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        editing,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        success,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)?
        error,
  }) {
    return success?.call(memorized, signal, output, current, transition);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        editing,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        success,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)?
        error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(memorized, signal, output, current, transition);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Editing value) editing,
    required TResult Function(_Success value) success,
    required TResult Function(_Error value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Editing value)? editing,
    TResult Function(_Success value)? success,
    TResult Function(_Error value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Editing value)? editing,
    TResult Function(_Success value)? success,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _Success extends RuleState {
  const factory _Success(
      {required final Map<AutomatoSignal, List<AutomatoRule>> memorized,
      final AutomatoSignal? signal,
      final AutomatoOutput? output,
      final AutomatoState? current,
      final AutomatoState? transition}) = _$_Success;
  const _Success._() : super._();

  @override
  Map<AutomatoSignal, List<AutomatoRule>> get memorized =>
      throw _privateConstructorUsedError;
  @override
  AutomatoSignal? get signal => throw _privateConstructorUsedError;
  @override
  AutomatoOutput? get output => throw _privateConstructorUsedError;
  @override
  AutomatoState? get current => throw _privateConstructorUsedError;
  @override
  AutomatoState? get transition => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SuccessCopyWith<_Success> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ErrorCopyWith<$Res> implements $RuleStateCopyWith<$Res> {
  factory _$ErrorCopyWith(_Error value, $Res Function(_Error) then) =
      __$ErrorCopyWithImpl<$Res>;
  @override
  $Res call(
      {Map<AutomatoSignal, List<AutomatoRule>> memorized,
      AutomatoSignal? signal,
      AutomatoOutput? output,
      AutomatoState? current,
      AutomatoState? transition,
      String error});
}

/// @nodoc
class __$ErrorCopyWithImpl<$Res> extends _$RuleStateCopyWithImpl<$Res>
    implements _$ErrorCopyWith<$Res> {
  __$ErrorCopyWithImpl(_Error _value, $Res Function(_Error) _then)
      : super(_value, (v) => _then(v as _Error));

  @override
  _Error get _value => super._value as _Error;

  @override
  $Res call({
    Object? memorized = freezed,
    Object? signal = freezed,
    Object? output = freezed,
    Object? current = freezed,
    Object? transition = freezed,
    Object? error = freezed,
  }) {
    return _then(_Error(
      memorized: memorized == freezed
          ? _value.memorized
          : memorized // ignore: cast_nullable_to_non_nullable
              as Map<AutomatoSignal, List<AutomatoRule>>,
      signal: signal == freezed
          ? _value.signal
          : signal // ignore: cast_nullable_to_non_nullable
              as AutomatoSignal?,
      output: output == freezed
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as AutomatoOutput?,
      current: current == freezed
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as AutomatoState?,
      transition: transition == freezed
          ? _value.transition
          : transition // ignore: cast_nullable_to_non_nullable
              as AutomatoState?,
      error: error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Error extends _Error with DiagnosticableTreeMixin {
  const _$_Error(
      {required final Map<AutomatoSignal, List<AutomatoRule>> memorized,
      this.signal,
      this.output,
      this.current,
      this.transition,
      required this.error})
      : _memorized = memorized,
        super._();

  final Map<AutomatoSignal, List<AutomatoRule>> _memorized;
  @override
  Map<AutomatoSignal, List<AutomatoRule>> get memorized {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_memorized);
  }

  @override
  final AutomatoSignal? signal;
  @override
  final AutomatoOutput? output;
  @override
  final AutomatoState? current;
  @override
  final AutomatoState? transition;
  @override
  final String error;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RuleState.error(memorized: $memorized, signal: $signal, output: $output, current: $current, transition: $transition, error: $error)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RuleState.error'))
      ..add(DiagnosticsProperty('memorized', memorized))
      ..add(DiagnosticsProperty('signal', signal))
      ..add(DiagnosticsProperty('output', output))
      ..add(DiagnosticsProperty('current', current))
      ..add(DiagnosticsProperty('transition', transition))
      ..add(DiagnosticsProperty('error', error));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Error &&
            const DeepCollectionEquality().equals(other.memorized, memorized) &&
            const DeepCollectionEquality().equals(other.signal, signal) &&
            const DeepCollectionEquality().equals(other.output, output) &&
            const DeepCollectionEquality().equals(other.current, current) &&
            const DeepCollectionEquality()
                .equals(other.transition, transition) &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(memorized),
      const DeepCollectionEquality().hash(signal),
      const DeepCollectionEquality().hash(output),
      const DeepCollectionEquality().hash(current),
      const DeepCollectionEquality().hash(transition),
      const DeepCollectionEquality().hash(error));

  @JsonKey(ignore: true)
  @override
  _$ErrorCopyWith<_Error> get copyWith =>
      __$ErrorCopyWithImpl<_Error>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)
        editing,
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)
        success,
    required TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)
        error,
  }) {
    return error(memorized, signal, output, current, transition, this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        editing,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        success,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)?
        error,
  }) {
    return error?.call(
        memorized, signal, output, current, transition, this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        editing,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition)?
        success,
    TResult Function(
            Map<AutomatoSignal, List<AutomatoRule>> memorized,
            AutomatoSignal? signal,
            AutomatoOutput? output,
            AutomatoState? current,
            AutomatoState? transition,
            String error)?
        error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(memorized, signal, output, current, transition, this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Editing value) editing,
    required TResult Function(_Success value) success,
    required TResult Function(_Error value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Editing value)? editing,
    TResult Function(_Success value)? success,
    TResult Function(_Error value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Editing value)? editing,
    TResult Function(_Success value)? success,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error extends RuleState {
  const factory _Error(
      {required final Map<AutomatoSignal, List<AutomatoRule>> memorized,
      final AutomatoSignal? signal,
      final AutomatoOutput? output,
      final AutomatoState? current,
      final AutomatoState? transition,
      required final String error}) = _$_Error;
  const _Error._() : super._();

  @override
  Map<AutomatoSignal, List<AutomatoRule>> get memorized =>
      throw _privateConstructorUsedError;
  @override
  AutomatoSignal? get signal => throw _privateConstructorUsedError;
  @override
  AutomatoOutput? get output => throw _privateConstructorUsedError;
  @override
  AutomatoState? get current => throw _privateConstructorUsedError;
  @override
  AutomatoState? get transition => throw _privateConstructorUsedError;
  String get error => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ErrorCopyWith<_Error> get copyWith => throw _privateConstructorUsedError;
}
